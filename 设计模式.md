# 设计模式

### 六大设计原则

#### 单一职责原则(SRP原则)

- 定义：有且只有一个原因引起类的变化。
- 要求接口、类、方法只有一个职责，只负责一件事情。
- **接口一定要做到单一职责**，类尽量做到只有一个原因引起变化。
- 单一职责原则的好处：
  - 类的复杂性降低，实现什么职责都有清晰明确的定义；
  - 可读性提高，复杂性降低，那当然可读性提高了；
  - 可维护性提高，可读性提高，那当然更容易维护了；
  - 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。

#### 里氏替换原则(LSP原则)

- 定义：所有引用基类的地方必须能透明地使用其子类的对象；

  通俗讲：**只要父类出现的地方子类就可以出现**。

- LSP原则为良好的继承定义了一个规范，包含4层含义：

  1. 子类必须完全实现父类的方法

     - **在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明违背了LSP原则**。

     - 如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。

  2. 子类可以有自己的个性

     - 有子类出现的地方父类未必就可以出现。

       例：狙击手是很依赖狙击枪的，换一个手枪或其他型号的枪肯定不行，所以这里就直接把子类狙击枪传递了进来。

  3. 覆盖或实现父类的方法时输入参数可以被放大

     - 子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松

  4. 覆写或实现父类的方法时输出结果可以被缩小

- **里氏替换原则是实现开闭的主要原则之一。开闭原则要求对扩展开放，扩展的一个实现手段就是使用继承；而里氏替换原则是保证子类型能够正确替换父类型，只有能正确替换，才能实现扩展。**

- 采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离。

#### 依赖倒置原则(DIP原则)

- 定义：包含三层含义：

  1. 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
  2. 接口或抽象类不依赖于实现类；
  3. 实现类依赖接口或抽象类。

- 更加精简的定义就是“面向接口编程”

- 采用依赖倒置原则可以减少类间的耦合性，提高系统的**稳定性**，**降低并行开发**引起的风险，提高代码的**可读性**和**可维护性**。

- 抽象是对实现的约束，对依赖者而言，也是一种契约，不仅仅约束自己，还同时约束自己与外部的关系，其目的是保证所有的细节不脱离契约的范畴，确保约束双方按照既定的契约（抽象）共同发展，只要抽象这根基线在，细节就脱离不了这个圈圈，始终让你的对象做到“言必信，行必果”。

- 依赖的三种传递方式：

  1. 构造函数传递依赖对象
  2. Setter方法传递依赖对象
  3. 接口声明依赖对象

- 依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合

- 遵循以下的几个规则：

  - 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。

    这是依赖倒置的基本要求，接口和抽象类都是属于抽象的，有了抽象才可能依赖倒置。

  - 变量的表面类型尽量是接口或者是抽象类

  - 尽量不要覆写基类的方法

    如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响。

  - 结合里氏替换原则使用

  - 接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。

#### 接口隔离原则(ISP原则)

- 定义：建立单一接口，不要建立臃肿庞大的接口。

  通俗讲：接口尽量细化，同时接口中的方法尽量少。

- 与单一职责的区别(审视角度是不同的)：

  - 单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分;
  - 接口隔离原则要求接口的方法尽量少。

- 接口隔离原则是对接口进行规范约束，其包含以下4层含义：

  - 接口要尽量小

    根据接口隔离原则拆分接口时，首先必须满足单一职责原则。

  - 接口要高内聚

    高内聚就是提高接口、类、模块的处理能力，减少对外的交互。

    具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。

  - 定制服务

    定制服务就是单独为一个个体提供优良的服务。

    采用定制服务就必然有一个要求：只提供访问者需要的方法。

  - 接口设计是有限度的

    接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低，这不是一个项目或产品所期望看到的，所以接口设计一定要注意适度。

- 接口和类尽量使用原子接口或原子类来组装，在实践中可以根据以下几个规则来衡量：

  - 一个接口只服务于一个子模块或业务逻辑
  - 通过业务逻辑压缩接口中的public方法
  - 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理

- 根据经验和常识决定接口的粒度大小，接口粒度太小，导致接口数据剧增，开发人员呛死在接口的海洋里；接口粒度太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。

#### 迪米特法则(LOD原则)

- 定义：一个对象应该对其他对象有最少的了解

- 迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义：

  1. 只和直接的朋友交流

     - 什么叫做直接的朋友呢？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。

     - 朋友类定义：

       出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而**出现在方法体内部的类不属于朋友类**(不允许方法体内出现其他陌生的类)。

  2. 朋友间也是有距离的

     - 一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。
     - 为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private、protected等访问权限，是否可以加上final关键字等。
     - 迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。

  3. 是自己的就是自己的

     在实际应用中经常会出现这样一个方法：放在本类中也可以，放在其他类中也没有错，那怎么去衡量呢？

     - 可以坚持这样一个原则：

       如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。

  4. 谨慎使用Serializable

     在实际应用中，这个问题是很少出现的，即使出现也会立即被发现并得到解决。

- 迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。

- 迪米特法则要求类间解耦，但解耦是有限度的这就需要大家在采用原则时反复度量，不遵循是不对的，严格执行就是“过犹不及”。

#### 开闭原则(OCP原则)

- 软件实体

  软件实体包括以下几个部分：

  - 项目或软件产品中按照一定的逻辑规则划分的模块。
  - 抽象和类。
  - 方法。

- **开闭原则告诉我们应尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化。**

- **开闭原则对扩展开放，对修改关闭**，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。

- 里氏替换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。

- 可以把变化归纳为以下三种类型：

  - 逻辑变化

    只变化一个逻辑，而不涉及其他模块，可以通过修改原有类中的方法的方式来完成，前提条件是所有依赖或关联类都按照相同的逻辑处理。

  - 子模块变化

    一个模块变化，会对其他的模块产生影响，特别是一个低层次的模块变化必然引起高层模块的变化，因此在通过扩展完成变化时，高层次的模块修改是必然的

  - 可见视图变化

    可见视图是提供给客户使用的界面，如JSP程序、Swing界面等，该部分的变化一般会引起连锁反应。如果仅仅是界面上按钮、文字的重新排布倒是简单，最司空见惯的是业务耦合变化。

- 为什么要采用开闭原则？

  开闭原则是最基础的一个原则，其它原则都是开闭原则的具体形态，也就是说前五个原则就是指导设计的工具和方法，而开闭原则才是其精神领袖。

- 通过以下几个方面来理解其重要性：

  1. 开闭原则对测试的影响

     有变化提出时，我们就需要考虑一下，原有的健壮代码是否可以不修改，仅仅通过扩展实现变化呢？否则，就需要把原有的测试过程回笼一遍，需要进行单元测试、功能测试、集成测试甚至是验收测试

  2. 开闭原则可以提高复用性

  3. 开闭原则可以提高可维护性

     维护人员最乐意做的事情就是扩展一个类，而不是修改一个类，甭管原有的代码写得多么优秀还是多么糟糕，让维护人员读懂原有的代码，然后再修改，是一件很痛苦的事情，不要让他在原有的代码海洋里游弋完毕后再修改，那是对维护人员的一种折磨和摧残。

  4. 面向对象开发的要求

     万物有变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之初考虑到所有可能变化的因素，然后留下接口，等待“可能”转变为“现实”。

- 如何使用开闭原则？

  1. 抽象约束

  2. 元数据（metadata）控制模块行为

     尽量使用元数据来控制程序的行为，减少重复开发。

     **元数据通俗讲就是：配置参数，参数可以从文件中获得，也可以从数据库中获得。**

  3. 制定项目章程

  4. 封装变化

     对变化的封装包含两层含义：

     ​	第一，将相同的变化封装到一个接口或抽象类中；

     ​	第二，将不同的变化封装到不同的接口或抽象类中

#### 总结

- 单一职责原则告诉我们实现类要职责单一；
- 里氏替换原则告诉我们不要破坏继承体系；
- 依赖倒置原则告诉我们要面向接口编程；
- 接口隔离原则告诉我们在设计接口的时候要精简单一；
- 迪米特法则告诉我们要降低耦合。
- 而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。

### 23种设计模式

#### 单例模式

- 定义：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

- 三元素：

  1. 私有化构造方法

     使得该类无法在外部通过new 进行实例化

  2. 类属性

     因为是类属性，所以共享一个

  3. public static getInstance方法

     返回2的类属性

- 分类：

  1. 饿汉式单例模式

     无论如何都会创建一个实例

  2. 懒汉式单例模式

     只有在调用getInstance的时候，才会创建实例

     - 准备一个类属性，用于指向一个实例化对象，但是暂时指向null
     - public static 方法 获取这个实例化对象;第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象；如果已指向一个对象，则不用创建直接返回对象

  3. 什么时候使用饿汉式，什么时候使用懒汉式？

     如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式。

- 优点：

  - 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时。
  - 单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。
  - 单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。

- 缺点：

  - 单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。

    单例模式为什么不能增加接口呢？因为接口对单例模式是没有任何意义的，它要求“自行实例化”。

  - 单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的。

  - 单例模式与单一职责原则有冲突。

- 使用场景：

  在一个系统中，要求一个类有且仅有一个对象，可以采用单例模式：

  - 要求生成唯一序列号的环境；
  - 在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器。
  - 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源。
  - 需要定义大量的静态常量和静态方法（如工具类）的环境。

- 最佳实践

  如在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理这些Bean的生命期，决定什么时候创建出来，什么时候销毁，销毁的时候要如何处理等等。

#### 工厂模式

1. ##### 工厂方法模式

   - 定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

   - 包含元素：

     1. Product

        抽象产品类Product负责定义产品的共性

     2. ConcreteProduct

        具体的产品类可以有多个，都继承于抽象产品类

     3. Creator

        Creator为抽象创建类，也就是抽象工厂

        抽象工厂类负责定义产品对象的生产

     4. ConcreteCreator

        具体如何创建产品类是由具体的实现工厂ConcreteCreator完成

   - 优点：

     - 良好的封装性，代码结构清晰

       如一个调用者需要一个具体的产品对象，只要知道这个产品的类名就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。

     - 工厂方法模式的扩展性非常优秀

       例如增加一个具体的产品类，工厂类不用任何修改就可完成系统扩展。

     - 屏蔽产品类

       产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。

       例：如果使用JDBC连接数据库，数据库从MySQL切换到Oracle，需要改动的地方就是切换一下驱动名称，不需要知道MySQL和Oracle是如何工作的。

     - 工厂方法模式是典型的解耦框架。

       高层模块值需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流；也符合依赖倒置原则，只依赖产品类的抽象；当然也符合里氏替换原则，使用产品子类替换产品父类，没问题！

   - 使用场景：

     - 工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用。

     - 需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。

       例：需要设计一个连接邮件服务器的框架，有三种网络协议可供选择：POP3、IMAP、HTTP，我们就可以把这三种连接方法作为产品类，定义一个接口如IConnectMail，

       然后定义对邮件的操作方法，用不同的方法实现三个具体的产品类（也就是
       连接方式）；

       再定义一个工厂方法，按照不同的传入条件，选择不同的连接方式。

       如此设计，可以做到完美的扩展，如某些邮件服务器提供了WebService接口，很好，我们只要增加一个产品类就可以了。

     - 工厂方法模式可以用在异构项目中

       例：通过WebService与一个非Java的项目交互，虽然WebService号称是可以做到异构系统的同构化，但是在实际的开发中，还是会碰到很多问题，如类型问题、WSDL文件的支持问题，等等。从WSDL中产生的对象都认为是一个产品，然后由一个具体的工厂类进行管理，减少与外围系统的耦合。

     - 可以使用在测试驱动开发的框架下

       例如，测试一个类A，就需要把与类A有关联关系的类B也同时产生出来，我们可以使用工厂方法模式把类B虚拟出来，避免类A与类B的耦合。

       目前由于JMock和EasyMock的诞生，该使用场景已经弱化了，读者可以在遇到此种情况时**直接考虑使用JMock或EasyMock**。

2. ##### 简单工厂模式

   - 一个模块仅需要一个工厂类，没有必要把它new出来，使用静态的方法就可以了；

   - 包含元素：

     1. Product

        抽象产品类Product负责定义产品的共性

     2. ConcreteProduct

        具体的产品类可以有多个，都继承于抽象产品类

     3. ConcreteCreator

        有一个static方法供直接调用

   - 在实际项目中，采用该方法的案例还是比较多的，

     其缺点是工厂类的扩展比较困难，不符合开闭原则，但它仍然是一个非常实用的设计模式。

3. ##### 抽象工厂模式

#### 观察者模式

- 定义：观察者模式（Observer Pattern）也叫做发布订阅模式（Publish/subscribe）；

  定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

- 四个角色：

  1. Subject被观察者

     定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者，管理观察者并通知观察者。

  2. Observer观察者

     观察者一般是一个接口，观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。

  3. ConcreteSubject具体的被观察者

     定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。

  4. ConcreteObserver具体的观察者

     每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑。

- 优点：

  - 观察者和被观察者之间是抽象耦合

    如此设计，则不管是增加观察者还是被观察者都非常容易扩展

  - 建立一套触发机制

    根据单一职责原则，每个类的职责是单一的，那么怎么把各个单一的职责串联成真实世界的复杂的逻辑关系呢？观察者模式可以完美地实现这种链条形式。

- 缺点：

  观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。

- 使用场景

  - 关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。
  - 事件多级触发场景。
  - 跨系统的消息交换场景，如消息队列的处理机制。

- 注意事项

  1. 广播链的问题

     根据经验建议，在一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消息最多转发一次（传递两次），这还是比较好控制的。

     **注意　它和责任链模式的最大区别就是观察者广播链在传播的过程中消息是随时更改的，它是由相邻的两个节点协商的消息结构；而责任链模式在消息传递过程中基本上保持消息不可变，如果要改变，也只是在原有的消息上进行修正。**

  2. 异步处理问题

     被观察者发生动作了，观察者要做出回应，如果观察者比较多，而且处理时间比较长怎么办？那就用异步呗，异步处理就要考虑线程安全和队列的问题。

- 最佳实践

  - 文件系统

    比如，在一个目录下新建立一个文件，这个动作会同时通知目录管理器增加该目录，并通知磁盘管理器减少1KB的空间，也就说“文件”是一个被观察者，“目录管理器”和“磁盘管理器”则是观察者。

  - 猫鼠游戏

    夜里猫叫一声，家里的老鼠撒腿就跑，同时也吵醒了熟睡的主人，这个场景中，“猫”就是被观察者，老鼠和人则是观察者。

  - ATM取钱

    比如你到ATM机器上取钱，多次输错密码，卡就会被ATM吞掉，吞卡动作发生的时候，会触发哪些事件呢？第一，摄像头连续快拍，第二，通知监控系统，吞卡发生；第三，初始化ATM机屏幕，返回最初状态。一般前两个动作都是通过观察者模式来完成的，后一个动作是异常来完成。

  - 广播收音机

    电台在广播，你可以打开一个收音机，或者两个收音机来收听，电台就是被观察者，收音机就是观察者。

#### 策略模式

- 定义：也叫做政策模式，定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。

- 策略模式使用的就是面向对象的继承和多态机制。

- 三个角色：

  1. Context封装角色

     它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。

  2. Strategy抽象策略角色

     策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。

  3. ConcreteStrategy具体策略角色

     实现抽象策略中的操作，该类含有具体的算法。

- 与代理模式的区别：

  **区别就是策略模式的封装角色和被封装的策略类不用是同一个接口，如果是同一个接口那就成为了代理模式。**

- 优点：

  - 算法可以自由切换

  - 避免使用多重条件判断

  - 扩展性良好

    在现有的系统中增加一个策略太容易了，只要实现接口就可以了，其他都不用修改，类似于一个可反复拆卸的插件，这大大地符合了OCP原则。

- 缺点：

  - 策略类数量增多

  - 所有的策略类都需要对外暴露

    上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与迪米特法则是相违背的，我只是想使用了一个策略，我凭什么就要了解这个策略呢？

- 使用场景：

  - 多个类只有在算法或行为上稍有不同的场景。
  - 算法需要自由切换的场景。
  - 需要屏蔽算法规则的场景。

- 注意事项

  **如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题**

- 策略枚举

  策略枚举定义如下：

  - 它是一个枚举。
  - 它是一个浓缩了的策略模式的枚举。

  ```
  public enum Calculator {
      //加法运算
      ADD(){
          public int exec(int a,int b){
              return a+b;
          }
      },
      //减法运算
      SUB(){
          public int exec(int a,int b){
              return a - b;
          }
      };
      public abstract int exec(int a, int b);
      Calculator() {}
  }
  ```

  **注意　策略枚举是一个非常优秀和方便的模式，但是它受枚举类型的限制，每个枚举项都是public、final、static的，扩展性受到了一定的约束，因此在系统开发中，策略枚举一般担当不经常发生变化的角色。**

- 最佳实践

  策略模式是一个非常简单的模式。它在项目中使用得非常多，但它单独使用的地方就比较少了，因为它有致命缺陷：所有的策略都需要暴露出去，这样才方便客户端决定使用哪一个策略。在实际项目中，我们一般通过工厂方法模式来实现策略类的声明。

#### 代理模式

- 定义：为其他对象提供一种代理以控制对这个对象的访问。

- 代理模式也叫做委托模式，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式，代理模式可以提供非常好的访问控制。

- 三角色：

  1. Subject抽象主题角色

     抽象主题类可以是抽象类也可以是接口，是一个最普通的业务类型定义，无特殊要求。

  2. RealSubject具体主题角色

     也叫做被委托角色、被代理角色。它才是冤大头(真正干活的角色)，是业务逻辑的具体执行者。

  3. Proxy代理主题角色

     也叫做委托类、代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作。

- 优点：

  - 职责清晰

    真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰。

  - 高扩展性

    具体主题角色是随时都会发生变化的，只要它实现了接口，甭管它如何变化，都逃不脱如来佛的手掌（接口），那我们的代理类完全就可以在不做任何修改的情况下使用。

  - 智能化

- 使用场景

  为什么要用代理呀？例：打官司为什么要找个律师？因为你不想参与中间过程的是是非非，只要完成自己的答辩就成，其他的比如事前调查、事后追查都由律师来搞定，这就是为了减轻你的负担。

  Spring AOP，这是一个非常典型的动态代理。

- 动态代理

  - InvocationHandler是JDK提供的动态代理接口，其中invoke方法是接口InvocationHandler定义必须实现的，它完成对真实方法的调用，动态代理是根据被代理的接口生成所有的方法。

    ```
    	@Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Object result = method.invoke(this.obj, args);
            return result;
    }
    ```

  - 动态代理实现代理的职责，业务逻辑Subject实现相关的逻辑功能，两者之间没有必然的相互耦合的关系。通知Advice从另一个切面切入，最终在高层模块也就是Client进行耦合，完成逻辑的封装任务。

- 最佳实践

  在学习AOP框架时，几个重要概念：

  **切面（Aspect）、切入点（JoinPoint）、通知（Advice）、织入（Weave）**

#### 适配器模式

- 定义：将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

- 适配器模式又叫做变压器模式，也叫做包装模式（Wrapper）。

- 三个角色：

  1. Target目标角色

     该角色定义把其他类转换为何种接口，也就是我们的期望接口。

  2. Adaptee源角色

     你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色。

  3. Adapter适配器角色

     适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：把源角色转换为目标角色，怎么转换？通过继承或是类关联的方式。

- 优点：

  - 适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。

  - 增加了类的透明性

    我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高层次模块是透明的，也是它不需要关心的。

  - 提高了类的复用度

    源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的角色。

  - 灵活性非常好

    某一天，突然不想要适配器，没问题，删除掉这个适配器就可以了，其他的代码都不用修改，基本上就类似一个灵活的构件，想用就用，不想就卸载。

- 使用场景

  适配器应用的场景只要记住一点就足够了：你有动机修改一个已经投产中的接口时，适配器模式可能是最适合你的模式。比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口。

- 注意事项

  项目一定要遵守依赖倒置原则和里氏替换原则，否则即使在适合使用适配器的场合下，也会带来非常大的改造。

- 最佳实践

  适配器模式是一个补偿模式，或者说是一个“补救”模式，通常用来解决接口不相容的问题。

#### 装饰模式

- 定义：动态地给一个对象添加一些额外的职责。**就增加功能来说，装饰模式相比生成子类更为灵活。**

- 四个角色：

  - Component抽象构件

    Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象，如上面的成绩单。

    **注意　在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当**
    **Component抽象构件。**

  -  ConcreteComponent 具体构件

    ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。

  - Decorator装饰角色

    一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个private变量指向Component抽象构件。

  - 具体装饰角色

    ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最原始的、最基本的东西装饰成其他东西，上面的例子就是把一个比较平庸的成绩单装饰成家长认可的成绩单。

  **注意　原始方法和装饰方法的执行顺序在具体的装饰类是固定的，可以通过方法重载实**
  **现多种执行顺序。**

- 优点：

  - 装饰类和被装饰类可以独立发展，而不会相互耦合。。换句话说，Component类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具
    体的构件。

  - 装饰模式是继承关系的一个替代方案。

    装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。

  - 装饰模式可以动态地扩展一个实现类的功能。

- 缺点：

  - 对于装饰模式记住一点就足够了：多层的装饰是比较复杂的。就像剥洋葱一样，你剥到了最后才发现是最里层的装饰出现了问题，因此，尽量减少装饰类的数量，以便降低系统的复杂度。

- 使用场景：

  - 需要扩展一个类的功能，或给一个类增加附加功能。
  - 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。
  - 需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。

- 最佳实践：

  装饰模式是对继承的有力补充。你要知道继承不是万能的，继承可以解决实际的问题，但是在项目中你要考虑诸如易维护、易扩展、易复用等，而且在一些情况下（比如上面那个成绩单例子）你要是用继承就会增加很多子类，而且灵活性非常差，那当然维护也不容易了，也就是说装饰模式可以替代继承，解决我们类膨胀的问题。同时，你还要知道继承是静态地给类增加功能，而装饰模式则是动态地增加功能，在上面的那个例子中，我不想要SortDecorator这层的封装也很简单，于是直接在Father中去掉就可以了，如果你用继承就必须修改程序。

  **装饰模式还有一个非常好的优点：扩展性非常好。**

#### 模板模式

- 定义：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

- 模板方法模式非常简单，仅仅使用了Java的继承机制；其中，AbstractClass叫做抽象模板，它的方法分为两类：

  1. 基本方法

     基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。

  2. 模板方法

     可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，
     完成固定的逻辑。

- **注意　为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写。**

- **注意　抽象模板中的基本方法尽量设计为protected类型，符合迪米特法则，不需要暴露的属性或方法尽量不要设置为protected类型。**实现类若非必要，尽量不要扩大父类中的访问权限。

- 优点：

  - 封装不变部分，扩展可变部分
  - 提取公共部分代码，便于维护
  - 行为由父类控制，子类实现

- 缺点：

  按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度。

- 使用场景：

  - 多个子类有公有的方法，并且逻辑基本相同时。
  - 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。
  - 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。

- 钩子函数

  抽象类中的方法的返回值影响了模板方法的执行结果，该方法就叫钩子方法，**有了钩子方法模板方法模式才算完美**。**由子类的一个方法返回值决定公共部分的执行结果**。

- 最佳实践

  父类怎么调用子类的方法呢？

  - 把子类传递到父类的有参构造中，然后调用。
  - 使用反射的方式调用，你使用了反射还有谁不能调用的？！
  - 父类调用子类的静态方法。

  项目中允许使用不？不允许！

  模板方法模式也可以理解为父类调用了子类的方法；你修改了子类，影响了父类行为的结果，曲线救国的方式实现了父类依赖子类的场景，模板方法模式就是这种效果。

#### 门面模式

门面模式（Facade Pattern）也叫做外观模式，是一种比较常用的封装模式。

- 定义：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。

- 门面模式注重“统一的对象”，也就是提供一个访问子系统的接口，除了这个接口不允许有任何访问子系统的行为发生。

- 再简单地说，门面对象是外界访问子系统内部的唯一通道，不管子系统内部是多么杂乱无章，只要有门面对象在，就可以做到“金玉其外，败絮其中”。

- 两个角色：

  1. Facade门面角色

     客户端可以调用这个角色的方法。此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去，也就说该角色没有实际的业务逻辑，只是一个委托类。

  2. subsystem子系统角色

     可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在。对于子系统而言，门面仅仅是另外一个客户端而已。

- 优点：

  - 减少系统的相互依赖

    如果我们不使用门面模式，外界访问直接深入到子系统内部，相互之间是一种强耦合关系，你死我就死，你活我才能活，这样的强依赖是系统设计所不能接受的，门面模式的出现就很好地解决了该问题，所有的依赖都是对门面对象的依赖，与子系统无关。

  - 提高了灵活性

    依赖减少了，灵活性自然提高了。不管子系统内部如何变化，只要不影响到门面对象，任你自由活动。

  - 提高安全性

    想让你访问子系统的哪些业务就开通哪些逻辑，不在门面上开通的方法，你休想访问到。

- 缺点：

  - 门面模式最大的缺点就是不符合开闭原则，对修改关闭，对扩展开放

- 使用场景：

  - 为一个复杂的模块或子系统提供一个供外界访问的接口

  - 子系统相对独立——外界对子系统的访问只要黑箱操作即可

  - 预防低水平人员带来的风险扩散

    比如一个低水平的技术人员参与项目开发，为降低个人代码质量对整体项目的影响风险，一般的做法是“画地为牢”，只能在指定的子系统中开发，然后再提供门面接口进行访问操作。

- 注意事项：

  - 一个子系统可以有多个门面

    一般情况下，一个子系统只要有一个门面足够了，在什么情况下一个子系统有多个门面呢？

    - 门面已经庞大到不能忍受的程度

    - 子系统可以提供不同访问路径

      现在有两个不同的高层模块来访问该子系统，模块一可以完整的访问所有业务逻辑，也就是通用代码中的Facade类，它是子系统的信任模块；而模块二属于受限访问对象，只能访问methodB方法，那该如何处理呢？在这种情况下，就需要建立两个门面以供不同的高层模块来访问。

  - 门面不参与子系统内的业务逻辑

- 最佳实践

  门面模式是一个很好的封装方法，一个子系统比较复杂时，比如算法或者业务比较复杂，就可以封装出一个或多个门面出来，项目的结构简单，而且扩展性非常好。还有，对于一个较大项目，为了避免人员带来的风险，也可以使用门面模式，技术水平比较差的成员，尽量安排独立的模块，然后把他写的程序封装到一个门面里，尽量让其他项目成员不用看到这些人的代码。

#### 状态模式

- 定义：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。

- 状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。

- 三个角色：

  1. State——抽象状态角色

     接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。

  2. ConcreteState——具体状态角色

     每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态处理，通俗地说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。

  3. Context——环境角色

     定义客户端需要的接口，并且负责具体状态的切换。

- 状态模式相对来说比较复杂，它提供了一种对物质运动的另一个观察视角，通过状态变更促使行为的变化，就类似水的状态变更一样，一碗水的初始状态是液态，通过加热转变为气态，状态的改变同时也引起体积的扩大，然后就产生了一个新的行为：鸣笛或顶起壶盖，瓦特就是这么发明蒸汽机的。

- 环境角色有两个不成文的约束：

  1. 把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。
  2. 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。

- 优点：

  - 结构清晰

    避免了过多的switch...case或者if...else语句的使用，避免了程序的复杂性,提高系统的可维护性。

  - 遵循设计原则

    很好地体现了开闭原则和单一职责原则，每个状态都是一个子类，你要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了。

  - 封装性非常好

    这也是状态模式的基本要求，状态变换放置到类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。

- 缺点：子类会太多，也就是类膨胀。

- 使用场景：

  - 行为随状态改变而改变的场景

    例如权限设计，人员的状态不同即使执行相同的行为结果也会不同。

  - 条件、分支判断语句的替代者

    在程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑混乱，使用状态模式可以很好地避免这一问题，它通过扩展子类实现了条件的判断处理。

- 注意事项

  状态模式适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个。

#### 命令模式

- 定义：命令模式是一个高内聚的模式，将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

- 三个角色：

  1. Receive接收者角色

     该角色就是干活的角色，命令传递到这里是应该被执行的。

  2. Command命令角色

     需要执行的所有命令都在这里声明。

  3. Invoker调用者角色

     接收到命令，并执行命令。

**命令模式比较简单，但是在项目中非常频繁地使用，因为它的封装性非常好，把请求方（Invoker）和执行方（Receiver）分开了，扩展性也有很好的保障。**

- 优点：

  - 类间解耦

    调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。

  - 可扩展性

  - 命令模式结合其他模式会更优秀

    命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少Command子类的膨胀问题。

- 缺点

  请看Command的子类：如果有N个命令，问题就出来了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大

- 使用场景

  只要你认为是命令的地方就可以采用命令模式。

#### 原型模式

- 定义：不通过new关键字来产生一个对象，而是通过对象复制来实现的模式就叫做原型模式。

- 原型模式的核心是一个clone方法，通过该方法进行对象的拷贝，Java提供了一个Cloneable接口来标示这个对象是可拷贝的；Cloneable是一个方法都没有的，这个接口只是一个标记作用，在JVM中具有这个标记的对象才有可能被拷贝。

- 那怎么才能从“有可能被拷贝”转换为“可以被拷贝”呢？方法是覆盖clone()方法，它覆写了Object类中的clone方法。

- 原型模式通用源码：

  ```
  public class PrototypeClass implements Cloneable{
  	//覆写父类Object方法
  	@Override
  	public PrototypeClass clone(){
  		PrototypeClass prototypeClass = null;
  		try {
  			prototypeClass = (PrototypeClass)super.clone();
  		} catch (CloneNotSupportedException e) {
  			//异常处理
  		}
  		return prototypeClass;
  	}
  }
  ```

- 优点：

  - 性能优良

    原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。

  - 逃避构造函数的约束

    这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。

- 使用场景：

  - 资源优化场景

    类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。

  - 性能和安全要求的场景

    通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。

  - 一个对象多个修改者的场景

    一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑
    使用原型模式拷贝多个对象供调用者使用(多线程？)。

  **在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。**

- 注意事项

  - 构造函数不会被执行

  - 浅拷贝和深拷贝

    - 浅拷贝

      Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝。

      内部的数组和引用对象不拷贝，其他的原始类型比如int、long、char等都会被拷贝，但是对于String类型，Java就希望你把它认为是基本类型，它是没有clone方法的，处理机制也比较特殊，通过字符串池（stringpool）在需要的时候才在内存中创建新的字符串。

      **注意　使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是一个原始类型或不可变对象。**

    - 深拷贝

      ```
      public class Thing implements Cloneable{
      	//定义一个私有变量
      	private ArrayList<String> arrayList = new ArrayList<String>();
      	@Override
      	public Thing clone(){
      		Thing thing=null;
      		try {
      			thing = (Thing)super.clone();
      			thing.arrayList = (ArrayList<String>)this.arrayList.clone();
      		} catch (CloneNotSupportedException e) {
      			e.printStackTrace();
      		}
      		return thing;
      	}
      }
      ```

    **注意　深拷贝和浅拷贝建议不要混合使用，特别是在涉及类的继承时，父类有多个引用**
    **的情况就非常复杂，建议的方案是深拷贝和浅拷贝分开实现。**

  - clone与final两个冤家

    **要使用clone方法，类的成员变量上不要增加final关键字。**

- 最佳实践

  原型模式先产生出一个包含大量共有信息的类，然后可以拷贝出副本，修正细节信息，建立了一个完整的个性对象。