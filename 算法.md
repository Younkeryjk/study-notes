# 算法

### 排序

#### 选择法排序

- 图解

  ![éæ©æ³æåº](http://stepimagewm.how2j.cn/573.png)

- 思路

  每次循环选择数组里一个最小的(最大的)放到最左边；

  选择到最小的(最大的)后，下次循环从剩下的数组里选择一个最小的(最大的)放到上一个最小的(最大的)后面；

  直到循环到倒数第二个数为止(因为剩最后一个数也不用比较了)

- 算法描述

  例如：一个有6个数从小到大排序：

  因为每次循环选择一个最小的(最大的)，所以一共需要5轮循环即可，剩下那个自然是最大的(最小的)不用比了；

  每轮循环当中，比如第1轮循环，需要从第2个后的所有数跟第1个数比较，比它小的就替换，直到比较到最后一个数，第1个数被替换成数组中最小的数；第2轮循环，则需要从第3个后的所有数跟第2个数比较。。。

- 代码

  ```
  for (int i = 0; i < a.length-1; i++) {
      for (int j = i + 1; j < a.length; j++) {
  		if (a[i] > a[j]) {
              t = a[i];
              a[i] = a[j];
              a[j] = t;
  		}
      }
  }
  ```

#### 冒泡法排序

- 图解

  ![åæ³¡æ³æåº](http://stepimagewm.how2j.cn/574.png)

- 思路

  每次循环依次比较相邻的两个数，较大的放到后面，这样最后的数最大；

  下次循环还是依次比较相邻的两个数，较大的放后面，已经排好序是最大数的就不需要进入循环了；

  直到剩一个数就没必要循环了。

- 算法描述

  例如：一个有6个数从小到大排序：

  以为每次冒出一个最大的数，需要5轮循环即可完成排序；

  每次循环中，比如第1轮循环，从左到右比较两个相邻的数，一直比较到全部的第6个数，得到最大的数；

  第2轮循环，从左到右比较两个相邻的数，因为最后一个数已经是最大数了，只需要比较到第5个数即可；

  此后每增加1轮，比较的数就少一个

- 代码

  ```
  for (int i = 0; i < a.length-1; i++) {
      for (int j = 0; j < a.length - i - 1; j++) {
  		if (a[j] > a[j+1]) {
  	    	t = a[j];
  	    	a[j] = a[j+1];
  	    	a[j+1] = t;
  		}
      }
  }
  ```

  