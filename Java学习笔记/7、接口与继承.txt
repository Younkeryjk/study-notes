1、接口
	> 接口就像是一种约定，接口的所有方法都没有方法体，是一个“空”方法
2、对象转型
	1) 明确引用类型与对象类型的概念
		> ADHero ad = new ADHero();在这个例子里，有一个对象 new ADHero(), 同时也有一个引用ad
		对象是有类型的， 是ADHero;引用也是有类型的，也是ADHero;通常情况下，引用类型和对象类型是一样的
	2) 子类转父类(向上转型)
		> 转型，是指把一个引用所指向的对象的类型，转换为另一个引用的类型；
		> 引用类型和对象类型不一致的时候，才需要进行类型转换
		> 类型转换有时候会成功，有时候会失败（父类转换为子类有时候会失败，子类转换父类都会成功）；
		> 一个很简单的判别能否转换成功的办法：把右边的当做左边来用，看说得通不：
		Hero h = new Hero();ADHero ad = new ADHero();h = ad;
		右边ad引用所指向的对象的类型是物理攻击英雄，左边h引用所指向的对象的类型是基类的英雄类;
		物理攻击英雄属于英雄，所以可以转换成功；
		> 所有的子类转换为父类，都是说得通的
	3) 父类转子类(向下转型)
		> 父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。
			> 什么时候行呢？
				1.	Hero h =new Hero();
				2.	ADHero ad = new ADHero();
				3.     h = ad;
				4.     ad = (ADHero) h;
				> 第3行，是子类转父类，一定可以的
				第4行，就是父类转子类，所以要进行强转。
				h这个引用，所指向的对象是ADHero, 所以第4行，就会把ADHero转换为ADHero，就能转换成功。
				注：如果去掉第三行，直接让h引用所指向的对象Hero转换为ADHero，会失败
			> 什么时候转换不行呢？
				1.        Hero h =new Hero();
				2.        ADHero ad = new ADHero();
				3.        Support s =new Support();
				4.        h = s;
				5.        ad = (ADHero)h;
				> 第4行，是子类转父类，是可以转换成功的;第5行，是把h引用所指向的对象 Support，
				转换为ad引用的类型ADHero。 从语义上讲，把物理攻击英雄，当成辅助英雄来用，说不通，
				所以会强制转换失败，并且抛出异常
	4) 没有继承关系的两个类，互相转换
		> 没有继承关系的两个类，互相转换，一定会失败
		虽然ADHero和APHero都继承了Hero，但是彼此没有互相继承关系
		把"魔法英雄"当做"物理英雄"来用,在语义上也是说不通的
	5) 实现类转换成接口(向上转型)
		> 向上转型，所以无需强制转换，并且一定能成功
		> 例：引用ad指向的对象是ADHero类型，这个类型实现了AD接口
		把一个ADHero当做AD来使用，而AD接口只有一个physicAttack方法，而ADHero一定是有physicAttack方法的，所以转换是能成功的。
	6) 接口转换成实现类(向下转型)
		> 例：
		1.	ADHero ad = new ADHero();
		2.	AD adi = ad;
		3.	ADHero adHero = (ADHero) adi;
		4.	ADAPHero adapHero = (ADAPHero) adi;
		5.	adapHero.magicAttack();
		2行： ad引用指向ADHero， 而adi引用是接口类型：AD，实现类转换为接口，是向上转型，所以无需强制转换，并且一定能成功
		3行: adi实际上是指向一个ADHero的，所以能够转换成功
		4行： adi引用所指向的对象是一个ADHero，要转换为ADAPHero就会失败。 
		假设能够转换成功，那么就可以使用magicAttack方法，而adi引用所指向的对象ADHero是没有magicAttack方法的。
	7) instanceof
		> instanceof Hero 判断一个引用所指向的对象，是否是Hero类型，或者Hero的子类
3、重写
	> 继承父类后，重新定义父类的方法，叫做重新，又叫覆盖Override
	1) 调用重写的方法，就会执行重写的方法，而不是从父类的方法
	2) 如果没有重写这样的机制怎么样？
		> 如果没有重写这样的机制，一旦继承了父类，所有方法都不能修改了。但子类有希望提供点不同的功能，
		会重新写一个类，大部分跟父类一样的方法和属性，增加开发及维护成本
4、多态
	1) 操作符的多态 ：
		> + 可以作为算数运算，也可以作为字符串连接 
		如果+号两侧都是整型，那么+代表 数字相加
		如果+号两侧，任意一个是字符串，那么+代表字符串连接
	2) 类的多态：父类引用指向子类对象
	3) 类的多态条件
		> 要实现类的多态，需要如下条件
			1. 父类（接口）引用指向子类对象
			2. 调用的方法有重写
	4) 类的多态-不使用多态
		> 如果不使用多态，假设英雄要使用血瓶和魔瓶，就需要为Hero设计两个方法
		useLifePotion、useMagicPotion
		除了血瓶和魔瓶还有很多种物品，那么就需要设计很多很多个方法，比如
		usePurityPotion 净化药水、useGuard 守卫、useInvisiblePotion 使用隐形药水等等
	5) 类的多态-使用多态
5、隐藏
	> 与重写类似，方法的重写是子类覆盖父类的对象方法；隐藏，就是子类覆盖父类的类方法
	> 注：父类类型的引用，但是指向一个子类对象，会调用父类的方法；
	因为静态方法会被子类继承，但不存在动态绑定，访问的是定义的对象变量所在的类或类本身的方法
6、super
	> 使用关键字super 显式调用父类的构造方法
	> 构造方法会被调用，其父类的构造方法也会被调用，并且是父类构造方法先调用 
	> super.fun(arg);//调用父类的方法
	> super.property;//调用父类的属性
	> 如果父类没有无参构造方法，则子类的构造器要显式地调用父类的带参数的构造器，且放在第一行
7、Object类
	1) Object类是所有类的父类
		> 声明一个类的时候，默认是继承了Object 
	2) toString()
		> Object类提供一个toString方法，所以所有的类都有toString方法
		toString()的意思是返回当前对象的字符串表达
		通过 System.out.println 打印对象就是打印该对象的toString()返回值
		> System.out.println(h.toString()); 等价于 System.out.println(h);
	3) finalize()
		> 当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件
		当它被垃圾回收的时候，它的finalize() 方法就会被调用。
		finalize() 不是开发人员主动调用的方法，而是由虚拟机JVM调用的。
		例：
			public void finalize(){
				System.out.println("这个英雄正在被回收");
			    }
			for (int i = 0; i < 10; i++) {
			    //不断生成新的对象
			    //每创建一个对象，前一个对象，就没有引用指向了
			    //那些对象，就满足垃圾回收的条件
			    //当垃圾堆积的比较多的时候，就会触发垃圾回收
			    //一旦这个对象被回收，它的finalize()方法就会被调用
			    h = new Hero();
			}
			结果输出10次"这个英雄正在被回收"，因为每次用同一个引用指向新的对象，前9个对象就没有引用指向了，
			等待被回收9次，最后循环结束，最后一个对象等待被回收(自己的理解)
	4) equals()
		> equals() 用于判断两个对象的内容是否相同：可以自定义对象的某些属性一样为相等
	5) ==
		> 用于判断两个引用，是否指向了同一个对象
	6) hashCode()
		> hashCode方法返回一个对象的哈希值
	7) 线程同步相关方法
		> Object还提供线程同步相关方法：wait() notify() notifyAll()
	8) getClass()
		> getClass()会返回一个对象的类对象，属于反射机制
8、final
	> final修饰类，方法，基本类型变量，引用的时候分别有不同的意思。
	1) final修饰类
		> 当类被修饰成final的时候，表示类不能够被继承
	2) final修饰方法
		> 当方法被修饰成final,表示这个方法不能被子类重写
	3) final修饰基本类型变量
		> final修饰基本类型变量，表示该变量只有一次赋值机会 
	4) final修饰引用
		> 引用被修饰成final，表示该引用只有1次指向对象的机会
		> 但是，依然通过引用修改对象的属性值，因为属性并没有final修饰
		例：
		final Hero h;
		h  =new Hero();
		h  =new Hero();//第二次指向新的对象，会报错
		h.hp = 5;//hp属性没有被修饰成final，所以可以修改
	5) 常量
		> 常量指的是可以公开，直接访问，不会变化的值 
		> public static final
9、抽象类
	1) 抽象类
		> 在类中声明一个方法，这个方法没有实现体，是一个“空”方法，这样的方法就叫抽象方法，使用修饰符“abstract" 
		> 当一个类有抽象方法的时候，该类必须被声明为抽象类
		> 子类必须提供抽象类里的抽象方法的实现
	2) 抽象类可以没有抽象方法
		> 抽象类可以不提供抽象方法
		> 抽象类不能被直接实例化
	3) 抽象类和接口的区别
		区别1：
			> 子类只能继承一个抽象类，不能继承多个
			> 子类可以实现多个接口
		区别2：
			> 抽象类可以定义
				1.public,protected,package,private
				2.静态和非静态属性
				3.final和非final属性
			> 接口中声明的属性，只能是public static final，即便没有显式的声明
10、内部类
	> 内部类分为四种：非静态内部类、静态内部类、匿名类、本地类
	1) 非静态内部类
		> 非静态内部类，只有在一个外部类对象存在的时候，才有意义：
		例：Hero garen = new Hero();
		BattleScore score = garen.new BattleScore();
		//BattleScore对象只有在一个英雄对象存在的时候才有意义
		// 所以其实例化必须建立在一个外部类对象的基础之上
		> 实例化语法: new 外部类().new 内部类()
		> 作为非静态内部类，是可以直接访问外部类的private实例属性的
	2) 静态内部类
		> 静态内部类实例化，不需要一个外部类的实例为基础，可以直接实例化
		> 语法：new 外部类.静态内部类();
		> 因为没有一个外部类的实例，所以在静态内部类里面不可以访问外部类的实例属性和方法
		除了可以访问外部类的私有静态成员外，静态内部类和普通类没什么大的区别
	3) 匿名类
		> 匿名类指的是在声明一个类的同时实例化它，使代码更加简洁精练
		> 通常情况下，要使用一个接口或者抽象类，都必须创建一个子类
		有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法
		既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类
	4) 本地类
		> 本地类可以理解为有名字的匿名类
		> 内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置
		本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等
	5) 在匿名类中使用外部的局部变量
		> 在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final(在jdk8中，已不需要强制修饰成final，因为编译器偷偷帮你加上了看不见的final)
11、默认方法
	1) 什么是默认方法
		> 默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法
		> 默认方法有实现体，并且被声明为了default
		例：default public void revive() {
			System.out.println("本英雄复活了");
		    }
	2) 为什么会有默认方法
		> 假设没有默认方法这种机制，那么如果接口增加一个新的方法，那么所有实现了接口的类，都需要做改动
		但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法
		通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类
		1. 若一个类A实现的两个接口B和C当中存在一个相同的default方法defaultMethod，则类A必须给出defaultMethod的实现
		2.若1中是一个接口B和一个类D，则遵从“类优先原则”，不要求A给出defaultMethod的实现。
