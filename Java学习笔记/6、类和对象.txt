1、引用
	1) 引用和指向
		> 如果一个变量的类型是 类类型，而非基本类型，那么该变量又叫做引用。
		> 为了访问对象，会使用引用来代表对象：Hero h = new Hero();
		h这个变量是Hero类型，又叫做引用，=的意思指的h这个引用代表右侧创建的对象，“代表” 在面向对象里，又叫做“指向”
	2) 多个引用，一个对象
		> 所有引用都指向了同一个对象： Hero h1 = new Hero();Hero h2 = h1; Hero h3 = h1;
	3) 一个引用，多个对象
		> 同一个引用改变了指向的对象，之前引用的对象已经无用：Hero garen =  new Hero();garen =  new Hero();(第一个Hero对象变得无用)
2、继承
3、方法重载
	> 方法的重载指的是方法名一样，但是参数类型不一样
	1) 方法的重载：public void attack()；public void attack(Hero h1)；public void attack(Hero h1, Hero h2)
	2) 可变数量的参数
		> public void attack(Hero ...heros)
4、构造方法
	> 通过一个类创建一个对象，这个过程叫做实例化 ；实例化是通过调用构造方法(又叫做构造器)实现的
	1) 什么是构造方法
		> 方法名和类名一样（包括大小写）没有返回类型 
		> 实例化一个对象的时候，必然调用构造方法
	2) 隐式的构造方法
		> 这个无参的构造方法，如果不写，就会默认提供一个：public Hero(){  }
	3) 如果提供了一个有参的构造方法
		> 一旦提供了一个有参的构造方法 同时又没有显式的提供一个无参的构造方法 那么默认的无参的构造方法，就“木有了“
	4) 构造方法的重载
		> 和普通方法一样，构造方法也可以重载
5、this
	1) this即代表当前对象
	2) 通过this访问属性
	3) 通过this调用其他的构造方法
		> public Hero(String name,float hp){
				this(name);
			}
6、传参
	> 变量有两种类型 基本类型 和类类型；参数也是变量，所以传参分为基本类型传参，类类型传参
	1) 基本类型传参
	2) 引用与=
		> 如果一个变量是基本类型，比如 int hp = 50;我们就直接管hp叫变量=表示赋值的意思。
		如果一个变量是类类型，比如 Hero h = new Hero();我们就管h叫做引用。=不再是赋值的意思
		=表示指向的意思。比如 Hero h = new Hero();这句话的意思是：引用h，指向一个Hero对象
	3) 类类型传参
		>	例子：
			public void revive(Hero h){h = new Hero("提莫",383);}Hero teemo =  new Hero("提莫",383);teemo.revive(teemo);
			引用teemo指向的还是原来的对象 Hero teemo =  new Hero("提莫",383);，而不是h = new Hero("提莫",383);引用h所指向的对象；
			二引用h先是指向Hero teemo =  new Hero("提莫",383);后因h = new Hero("提莫",383);改变了指向
7、包
	1) 把比较接近的类，规划在同一个包下
	2) 使用其他包下的类，必须import
		> 使用同一个包下的其他类，直接使用即可 ；但是要使用其他包下的类，必须import
8、访问修饰符
	> 成员变量有四种修饰符：private 私有的、package/friendly/default 不写、protected 受保护的、public 公共的
	1) 类之间的关系
		类和类之间的关系有如下几种:
		> 自身
		> 同包子类
		> 不同包子类
		> 同包类
		> 其他类
	2) private 私有的
		使用private修饰属性：
		> 自身：是可以访问的
		> 同包子类：不能继承
		> 不同包子类：不能继承
		> 同包类：不能访问
		> 其他包类：不能访问
	3) package/friendly/default 不写
		没有修饰符即代表package/friendly/default ：
		> 自身：可以访问
		> 同包子类：可以继承
		> 同包类：可以访问
		> 不同包子类：不能继承
		> 其他包类：不能访问
	4) protected 受保护的
		> 自身：可以访问
		> 同包子类：可以继承
		> 同包类：可以访问
		> 不同包子类：可以继承
		> 其他包类：不能访问
	5) public 公共的
		> 自身：可以访问
		> 同包子类：可以继承
		> 同包类：可以访问
		> 不同包子类：可以继承
		> 其他包类：可以访问
	6) 修饰符使用原则：作用范围最小原则
		> 属性通常使用private封装起来
		> 方法一般使用public用于被调用
		> 会被子类继承的方法，通常使用protected
		> package用的不多，一般新手会用package,因为还不知道有修饰符这个东西
9、类属性
	> 当一个属性被static修饰的时候，就叫做类属性，又叫做静态属性；当一个属性被声明成类属性，那么所有的对象，都共享一个值
	> 与对象属性对比： 不同对象的 对象属性 的值都可能不一样。 但是所有对象的类属性的值，都是一样的
	1) 类属性
		> 类属性： 又叫做静态属性;对象属性： 又叫实例属性，非静态属性
	2) 访问类属性
		访问类属性有两种方式：
		1) 对象.类属性
		2)  类.类属性
			> 这两种方式都可以访问类属性，访问即修改和获取，但是建议使用第二种 类.类属性 的方式进行，这样更符合语义上的理解
			> 注意：修改类属性后，所有对象的类属性都会被修改
	3) 什么时候使用对象属性，什么时候使用类属性
		> 如果一个属性，每个对象都不一样，比如name，这样的属性就应该设计为对象属性，因为它是跟着对象走的，每个对象的name都是不同的
		> 如果一个属性，所有的对象都共享，都是一样的，那么就应该设计为类属性
10、类方法
	1) 类方法
		> 类方法： 又叫做静态方法；对象方法： 又叫实例方法，非静态方法 
		> 访问一个对象方法，必须建立在有一个对象的前提的基础上
		> 访问类方法，不需要对象的存在，直接就访问
	2) 调用类方法
		> 和访问类属性一样，调用类方法也有两种方式：
			1) 对象.类方法
			2) 类.类方法
		> 这两种方式都可以调用类方法，但是建议使用第二种 类.类方法 的方式进行，这样更符合语义上的理解。
		> 并且在很多时候，并没有实例，比如在前面练习的时候用到的随机数的获取办法：Math.random()
		random()就是一个类方法，直接通过类Math进行调用，并没有一个Math的实例存在。
	3) 什么时候设计对象方法，什么时候设计类方法
		> 如果一个方法，没有调用任何对象属性，那么就可以考虑设计为类方法；
		不和某一个具体的对象关联起来，所有的对象都是一样的;这样的方法，
		更带有功能性色彩，就像取随机数一样
		> 如果在某一个方法里，调用了对象属性，比如public String getName(){return name;}
		只有存在一个具体对象的时候，name才有意义。那么这个方法，就必须设计为对象方法
	4) 注：类方法只能访问类属性，只能调用其他类方法
11、属性初始化
	1) 对象属性初始化
		对象属性初始化有3种：
		> 1. 声明该属性的时候初始化 
		> 2. 构造方法中初始化
		> 3. 初始化块
		> 执行顺序：声明>初始化块>构造方法
		public String name = "some hero"; //声明该属性的时候初始化
		protected float hp;
		float maxHP;
		{
			maxHP = 200; //初始化块
		}  
		public Hero(){
			hp = 100; //构造方法中初始化
		}
	2) 类属性初始化
		类属性初始化有2种：
			> 1. 声明该属性的时候初始化
			> 2. 静态初始化块
			public static int itemCapacity=8; //声明的时候 初始化
			static{
				itemCapacity = 6;//静态初始化块 初始化
			}
12、单例模式
	1) 单例模式
		> 单例模式又叫做 Singleton模式，指的是一个类，在一个JVM里，只有一个实例存在
	2) 饿汉式单例模式
		> 无论如何都会创建一个实例，分三步骤：
		> 私有化构造方法使得该类无法在外部通过new 进行实例化
		> 准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个
		> public static 方法 获取这个实例化对象
	3) 懒汉式单例模式
		> 只有在调用getInstance的时候，才会创建实例，也分三步骤：
		> 私有化构造方法使得该类无法在外部通过new 进行实例化
		> 准备一个类属性，用于指向一个实例化对象，但是暂时指向null
		>  public static 方法 获取这个实例化对象;第一次访问的时候，发现instance没有指向任何对象，
		这时实例化一个对象；如果已指向一个对象，则不用创建直接返回对象
	4) 什么时候使用饿汉式，什么时候使用懒汉式
		> 饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载。
		如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。
		> 懒汉式，是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量。
		使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。
		但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。
		> 看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式
	5) 单例模式三元素：
		1. 构造方法私有化
		2. 静态属性指向实例
		3. public static的 getInstance方法，返回第二步的静态属性
13、枚举类型
	1) 预先定义的常量
		> 枚举enum是一种特殊的类(还是类)，使用枚举可以很方便的定义常量
		比如设计一个枚举类型 季节，里面有4种常量：
		public enum Season {
			SPRING,SUMMER,AUTUMN,WINTER
		}
		> 一个常用的场合就是switch语句中，使用枚举来进行判断
		> 注：因为是常量，所以一般都是全大写
	2) 使用枚举的好处
		> 使用枚举，就能把范围死死的限定在这四几个常量当中
		假设在使用switch的时候，不是使用枚举，而是使用int，而int的取值范围就不只是1-4，
		有可能取一个超出1-4之间的值，这样判断结果就似是而非了。（因为只有4个季节）
	3) 遍历枚举
		> 枚举类.values() 是所有枚举类的常量
		> 借助增强型for循环，可以很方便的遍历一个枚举都有哪些常量
		for (Season s : Season.values()) {
	        }