1、启动一个线程
	> 多线程即在同一时间，可以做多件事情。 
	> 创建多线程有3种方式，分别是继承线程类，实现Runnable接口，匿名类
	1) 线程概念
		> 进程：启动一个应用程序就叫一个进程
		> 线程：线程是在进程内部同时做的事情。
		   例：比如在LOL里，有很多事情要同时做，比如“盖伦”击杀“提莫”，同时“赏金猎人”又在击杀“盲僧”，这就是由多线程实现的。
	2) 继承线程类
		> 设计一个多线程类，继承Thread，并且重写run方法
		> 启动线程方法：实例化一个多线程对象，并调用其start方法
	3) 实现Runnable接口
		> 创建一个多线程类，实现Runnable接口；
		> 启动线程方法：实例化一个多线程对象，然后根据该对象创建一个线程对象，并调用其start方法
	4) 匿名类
		> 使用匿名类方式：实例化Thread对象，并重写run方法，并调用其start方法
		> 匿名类的一个好处是可以很方便的访问外部的局部变量。前提是外部的局部变量需要被声明为final。(JDK7以后就不需要了)
	5) 创建多线程的三种方式
		1> 继承Thread类
		2> 实现Runnable接口
		3> 匿名类的方式
		>   注：启动线程是start()方法，run()并不能启动一个新的线程
2、常见线程方法
	1) 当前线程暂停
		> Thread.sleep(1000); 表示当前线程暂停1000毫秒 ，其他线程不受影响
	2) 加入到主线程中
		>  t1.join() 表示把t1线程加入到主线程中，主线程会等待t1线程结束后，才会往下运行
	3) 线程优先级
		> 优先级高的线程会有更大的几率获得CPU资源
		> 最高优先级：t1.setPriority(Thread.MAX_PRIORITY);
		> 最低优先级：t2.setPriority(Thread.MIN_PRIORITY);
	4) 临时暂停 Thread.yield();
		> 当前线程，临时暂停，使其他线程可以有更多的机会占用CPU资源
	5) 守护线程 t1.setDaemon(true);
		> 守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。
		> 就好像一个公司，有销售部、生产部、后勤部。如果销售部、生产部解散了，那留后勤部这种支持部门也没用了
		> 守护线程通常会被用来做日志，性能优化等
3、同步
	1) 分析同步问题产生的原因：
		1. 假设增加线程先进入，得到的hp是10000 
		2. 进行增加运算 
		3. 正在做增加运算的时候，还没有来得及修改hp的值，减少线程来了 
		4. 减少线程得到的hp的值也是10000 
		5. 减少线程进行减少运算 
		6. 增加线程运算结束，得到值10001，并把这个值赋予hp 
		7. 减少线程也运算结束，得到值9999，并把这个值赋予hp 
		hp，最后的值就是9999 
		虽然经历了两个线程各自增减了一次，本来期望还是原值10000，但是却得到了一个9999 
		这个时候的值9999是一个错误的值，在业务上又叫做脏数据
	2) 解决思路
		总体解决思路是： 在增加线程访问hp期间，其他线程不可以访问hp 
		1. 增加线程获取到hp的值，并进行运算 
		2. 在运算期间，减少线程试图来获取hp的值，但是不被允许 
		3. 增加线程运算结束，并成功修改hp的值为10001 
		4. 减少线程，在增加线程做完后，才能访问hp的值，即10001 
		5. 减少线程运算，并得到新的值10000
	3) synchronized 同步对象概念
		> Object someObject =new Object();
		   synchronized (someObject){
			//此处的代码只有占有了someObject后才可以执行
		  }
		  synchronized表示当前线程，独占 对象 someObject
		当前线程独占 了对象someObject，如果有其他线程试图占有对象someObject，就会等待，直到当前线程释放对someObject的占用。
		> someObject 又叫同步对象，所有的对象，都可以作为同步对象
		> 为了达到同步的效果，必须使用同一个同步对象
		> 释放同步对象的方式： synchronized 块自然结束，或者有异常抛出
	4) 解决同步问题的3种方式
		1> 在调用类的需要同步的方法的外面加 synchronized (someObject){}
		2> 在类的需要同步的方法里加 synchronized (this) {}
		3> 在类的需要同步的方法前加synchronized修饰符
	5) 线程安全的类
		> 如果一个类，其方法都是有synchronized修饰的，那么该类就叫做线程安全的类
		> 同一时间，只有一个线程能够进入这个类的一个实例去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)
4、线程安全的类
	1) HashMap和Hashtable的区别
		> HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式
		1> 区别1：
			> HashMap可以存放null
			> Hashtable不可以存放null
		2> 区别2：
			> HashMap不是线程安全的类
			> Hashtable是线程安全的类
	2) StringBuffer和StringBuilder的区别
		> StringBuffer是线程安全的 StringBuilder是非线程安全的
		> 所以当进行大量字符串拼接操作的时候，如果单线程就使用StringBuilder会快一些，
		   如果是多线程，就需要用StringBuffer保证数据的安全
		> 非线程安全的为什么会比线程安全的快呢？因为不需要同步，省了些时间
	3) ArrayList和Vector的区别
		> Vector是线程安全的类，ArrayList是非线程安全的类
	4) 把非线程安全的集合转换为线程安全
		> 借助Collections.synchronizedList，可以把ArrayList转换为线程安全的List
5、死锁
	1) 死锁示例演示
		1. 线程1 首先占有对象1，接着试图占有对象2
		2. 线程2 首先占有对象2，接着试图占有对象1
		3. 线程1 等待线程2释放对象2
		4. 与此同时，线程2等待线程1释放对象1
		就会。。。一直等待下去，直到天荒地老，海枯石烂，山无棱 ，天地合。。。
6、交互
	> 线程之间有交互通知的需求
	   例：
	   	有两个线程，处理同一个英雄。 
		一个加血，一个减血。 
		减血的线程，发现血量=1，就停止减血，直到加血的线程为英雄加了血，才可以继续减血
	1) 不好的解决方式
		> 使用while循环判断，这是不好的解决方式，因为会大量占用CPU,拖慢性能
		    例：故意设计减血线程频率更高，盖伦的血量迟早会到达1
		           减血线程中使用while循环判断是否是1，如果是1就不停的循环,直到加血线程回复了血量
	2) 使用wait和notify进行线程交互
		> this.wait()表示 让占有this的线程等待，并临时释放占有
		> this.notify() 表示通知那些等待在this的线程，可以苏醒过来了
	3) 关于wait、notify和notifyAll
		> 这里需要强调的是，wait方法和notify方法，并不是Thread线程上的方法，它们是Object上的方法。
		> 因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。
		1> wait()的意思是： 让占用了这个同步对象的线程，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。
		2> notify() 的意思是，通知一个等待在这个同步对象上的线程，你可以苏醒过来了，有机会重新占用当前对象了。
		3> notifyAll() 的意思是，通知所有的等待在这个同步对象上的线程，你们可以苏醒过来了，有机会重新占用当前对象了。
7、线程池
	> 每一个线程的启动和结束都是比较消耗时间和占用资源的。为了解决这个问题，引入线程池这种设计思想。
	> 线程池的模式很像生产者消费者模式，消费的对象是一个一个的能运行的任务。
	1) 线程池设计思路
		> 线程池的思路和生产者消费者模型是很接近的。在整个过程中，
		    都不需要创建新的线程，而是循环使用这些已经存在的线程。
			1> 准备一个任务容器
			2> 一次性启动10个 消费者线程
			3> 刚开始任务容器是空的，所以线程都wait在上面。
			4> 直到一个外部线程往这个任务容器中扔了一个“任务”，就会有一个消费者线程被唤醒notify
			5> 这个消费者线程取出“任务”，并且执行这个任务，执行完毕后，继续等待下一次任务的到来。
			6> 如果短时间内，有较多的任务加入，那么就会有多个线程被唤醒，去执行这些任务。
	2) 使用java自带线程池
		> 线程池类ThreadPoolExecutor在包java.util.concurrent下
		1> 第一个参数10 表示这个线程池初始化了10个线程在里面工作
		2> 第二个参数15 表示如果10个线程不够用了，就会自动增加到最多15个线程
		3> 第三个参数60 结合第四个参数TimeUnit.SECONDS，表示经过60秒，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个
		4> 第四个参数TimeUnit.SECONDS 如上
		5> 第五个参数 new LinkedBlockingQueue() 用来放任务的集合
		> execute方法用于添加新的任务
8、Lock对象
	> 与synchronized类似的，lock也能够达到同步的效果
	1) 回忆 synchronized 同步的方式
		> 当一个线程占用 synchronized 同步对象，其他线程就不能占用了，直到释放这个同步对象为止
	2) 使用Lock对象实现同步效果
		> Lock是一个接口： Lock lock = new ReentrantLock();
		> 与synchronized(someObject) 类似，lock()方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。
		> 与synchronized不同的是，一旦synchronized块结束，就会自动释放对someObject的占用。lock却必须调用unlock方法
		   进行手动释放，为了保证释放的执行，往往会把unlock()放在finally中进行。
	3) trylock方法
		> synchronized是不占用到手不罢休的，会一直试图占用下去。
		> 与synchronized的钻牛角尖不一样，Lock接口还提供了一个trylock方法：
		   会在指定的时间范围内试图占用，如果时间到了，还占用不成功，就会放弃占用。
		> 因为trylock有可能成功，有可能失败，所以后面unlock释放锁时，需要判断是否占用成功了，
		   如果没有占用成功也unlock，就会抛出异常。
	4) 线程交互
		> 使用synchronized方式进行线程交互，用到的是同步对象的wait，notify和notifyAll；Lock也类似
		   首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的await，signal，signalAll方法
	5) 总结Lock和synchronized的区别
		1> Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。
		2> Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。
		     借助Lock这个特性，就能规避死锁，synchronized必须通过谨慎和良好设计，才能减少死锁的发生。
		3> synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放，所以如果忘记了释放锁，一样会造成死锁。
9、原子访问
	1) 原子性操作概念
		> 所谓的原子性操作即不可中断的操作，比如赋值操作：int i = 5;
		> 原子性操作本身是线程安全的
		例：
			但是 i++ 这个行为，事实上是有3个原子性操作组成的。
			步骤 1. 取 i 的值
			步骤 2. i + 1
			步骤 3. 把新的值赋予i
			这三个步骤，每一步都是一个原子操作，但是合在一起，就不是原子操作。就不是线程安全的。 
	2) AtomicInteger
		> 包java.util.concurrent.atomic，里面有各种原子类，比如AtomicInteger。
		> 而AtomicInteger提供了各种自增，自减等方法，这些方法都是原子性的。 
		   自增方法 incrementAndGet 是线程安全的，同一个时间，只有一个线程可以调用这个方法。